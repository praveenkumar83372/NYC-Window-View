name: NYC 12hr Seamless Shield

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *' # Restarts every 24 hours to stay under the 12hr archive limit

jobs:
  stream:
    runs-on: ubuntu-latest
    timeout-minutes: 715 # 11 hours and 55 minutes to guarantee replay
    steps:
      - name: 1. Install FFmpeg & Python
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          pip install supabase requests

      - name: 2. Start Seamless 24/7 Engine
        env:
          SUPABASE_URL: "https://ofqbyabbjpincectjdya.supabase.co"
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          STREAM_KEY: ${{ secrets.STREAM_KEY }}
        run: |
          python - <<EOF
          import os, time, subprocess, requests
          from supabase import create_client

          supabase = create_client(os.environ.get("SUPABASE_URL"), os.environ.get("SUPABASE_KEY"))
          stream_url = f"rtmp://a.rtmp.youtube.com/live2/{os.environ.get('STREAM_KEY')}"
          
          # Timer to stop at 11:55:00 for the archive
          start_time = time.time()
          limit_seconds = (11 * 3600) + (55 * 60)

          def download_playlist():
              """Download all current videos locally to prevent 'Broken Pipe' errors"""
              response = supabase.table("playlist").select("url").execute()
              urls = [row['url'] for row in response.data] if response.data else []
              
              if not os.path.exists('videos'): os.makedirs('videos')
              
              with open("list.txt", "w") as f:
                  for i, url in enumerate(urls):
                      local_path = f"videos/vid_{i}.mp4"
                      r = requests.get(url, stream=True)
                      with open(local_path, 'wb') as vid:
                          for chunk in r.iter_content(chunk_size=8192): vid.write(chunk)
                      f.write(f"file '{os.path.abspath(local_path)}'\n")
              return len(urls)

          print("ðŸš€ Downloading NYC Library...")
          count = download_playlist()

          if count > 0:
              print(f"ðŸŽ¥ Starting Seamless Stream for {count} videos...")
              # THE "GAPLESS" FIX:
              # -f concat: FFmpeg treats all videos as ONE long continuous file.
              # -stream_loop -1: If the playlist ends before 11:55, it loops back to start.
              # This keeps the YouTube connection alive without a single micro-break.
              
              cmd = [
                  "ffmpeg", "-hide_banner", "-loglevel", "warning",
                  "-re", "-f", "concat", "-safe", "0", "-stream_loop", "-1", "-i", "list.txt",
                  "-c:v", "libx264", "-preset", "ultrafast", "-tune", "zerolatency",
                  "-profile:v", "high", "-level", "4.1", "-pix_fmt", "yuv420p",
                  "-vf", "scale=720:1280,format=yuv420p",
                  "-b:v", "3000k", "-maxrate", "3000k", "-bufsize", "14M",
                  "-nal-hrd", "cbr", "-g", "60", "-keyint_min", "60",
                  "-c:a", "aac", "-ar", "44100", "-b:a", "128k",
                  "-f", "flv", stream_url
              ]
              
              # Run until the 11h 55m timeout kills the job
              subprocess.run(cmd, timeout=limit_seconds)
          EOF
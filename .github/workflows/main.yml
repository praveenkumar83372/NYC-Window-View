name: NYC Walking Peak-Time Streamer

on:
  workflow_dispatch:
  schedule:
    # Runs twice a day at US Peak Times (1PM and 9PM UTC)
    - cron: '0 13,21 * * *'

jobs:
  stream:
    runs-on: ubuntu-latest
    steps:
      - name: 1. Install FFmpeg & Python
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          pip install supabase requests

      - name: 2. Process and Stream Walking Playlist
        env:
          SUPABASE_URL: "https://ofqbyabbjpincectjdya.supabase.co"
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          STREAM_KEY: ${{ secrets.STREAM_KEY }}
          TELEGRAM_BOT_TOKEN: "8388212435:AAHuhQ7XSf4eJKxswzyW0yk5ALEYV-x4I7U"
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          python - <<EOF
          import os, time, subprocess, requests
          from supabase import create_client

          supabase = create_client(os.environ.get("SUPABASE_URL"), os.environ.get("SUPABASE_KEY"))
          stream_url = f"rtmp://a.rtmp.youtube.com/live2/{os.environ.get('STREAM_KEY')}"
          tg_token = os.environ.get("TELEGRAM_BOT_TOKEN")
          tg_chat = os.environ.get("TELEGRAM_CHAT_ID")

          def send_tg(msg):
              url = f"https://api.telegram.org/bot{tg_token}/sendMessage"
              requests.post(url, data={"chat_id": tg_chat, "text": msg})

          def get_assets():
              response = supabase.table("playlist").select("url").execute()
              urls = [row['url'] for row in response.data] if response.data else []
              
              if not urls:
                  send_tg("‚ö†Ô∏è NYC Engine: No walking videos found in playlist for this peak session.")
                  return 0
              
              if not os.path.exists('videos'): os.makedirs('videos')
              with open("list.txt", "w") as f:
                  for i, url in enumerate(urls):
                      local_path = f"videos/walk_{i}.mp4"
                      r = requests.get(url, stream=True)
                      with open(local_path, 'wb') as vid:
                          for chunk in r.iter_content(chunk_size=8192): vid.write(chunk)
                      f.write(f"file '{os.path.abspath(local_path)}'\n")
              return len(urls)

          count = get_assets()

          if count > 0:
              send_tg(f"üé• NYC Engine: Peak-Time Stream Starting with {count} walking clips.")
              
              # THE CENTER CROP & SEQUENTIAL STREAM
              # No Loop: It plays the Telegram links once and then stops for replay archiving
              cmd = [
                  "ffmpeg", "-hide_banner", "-loglevel", "warning",
                  "-re", "-f", "concat", "-safe", "0", "-i", "list.txt",
                  "-c:v", "libx264", "-preset", "ultrafast", "-tune", "zerolatency",
                  "-profile:v", "high", "-level", "4.1", "-pix_fmt", "yuv420p",
                  "-vf", "crop=ih*9/16:ih,scale=720:1280,format=yuv420p",
                  "-b:v", "3500k", "-maxrate", "3500k", "-bufsize", "14M",
                  "-nal-hrd", "cbr", "-g", "60", "-keyint_min", "60",
                  "-c:a", "aac", "-ar", "44100", "-b:a", "128k",
                  "-f", "flv", stream_url
              ]
              
              # Limit to 11h 55m for YouTube Replay limit
              try:
                  subprocess.run(cmd, timeout=42900)
                  # Automatically clear playlist after successful stream
                  supabase.table("playlist").delete().neq("url", "clear").execute()
                  send_tg("‚úÖ NYC Engine: Stream finished. Playlist cleared for next session.")
              except Exception as e:
                  send_tg(f"‚ùå NYC Engine: Error during stream: {str(e)}")
          EOF